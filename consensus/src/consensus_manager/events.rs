use crate::{consensus::ConsensusMessage, crypto::aggregated::PeerId};

/// Events emitted by the view progress manager to drive the consensus protocol forward.
///
/// [`ViewProgressEvent`] represents the various actions that a replica must take during
/// the execution of the consensus protocol. These events are generated by the view progress
/// manager in response to incoming consensus messages, timeouts, or internal state transitions.
///
/// The view progress manager processes consensus messages and the current state of the protocol,
/// then emits these events to instruct the replica on what actions to perform next, such as:
/// - Proposing blocks (if the replica is the leader)
/// - Voting for proposed blocks
/// - Notarizing blocks (M-notarization)
/// - Finalizing blocks
/// - Nullifying views (when consensus cannot be reached)
/// - Broadcasting consensus messages to other replicas
/// - Progressing to new views
///
/// # Type Parameters
///
/// * `N` - Total number of replicas in the consensus network
/// * `F` - Maximum number of faulty replicas that can be tolerated (typically `N = 3F + 1`)
/// * `M_SIZE` - Size of the aggregated signature used for M-notarizations
#[derive(Clone, Debug)]
pub enum ViewProgressEvent<const N: usize, const F: usize, const M_SIZE: usize> {
    /// If the current replica is the leader for the current `view`,
    /// and it should propose a block for the current view.
    ShouldProposeBlock {
        /// Current view number (for which the replica is the leader).
        view: u64,
        /// The hash of the parent block (that is, the last finalized block
        /// in the protocol).
        parent_block_hash: [u8; blake3::OUT_LEN],
    },

    /// If the current replica should vote for a block for the current view.
    ShouldVote {
        /// Current view number (for which the replica should vote).
        view: u64,
        /// The hash of the block that the replica should vote for.
        block_hash: [u8; blake3::OUT_LEN],
    },

    /// If the current replica should nullify the current view.
    ShouldNullify {
        /// Current view number (for which the replica should nullify).
        view: u64,
    },

    /// If the current replica should broadcast a nullification for the current view.
    ShouldBroadcastNullification {
        /// The view number for which the replica should nullify.
        view: u64,
    },

    /// If the current replica should M-notarize a block for the current view.
    ShouldMNotarize {
        /// Current view number (for which the replica should notarize).
        view: u64,
        /// The hash of the block that the replica should notarize.
        block_hash: [u8; blake3::OUT_LEN],
        /// Whether the replica should forward the M-notarization to the network layer.
        should_forward_m_notarization: bool,
    },

    /// If the current replica should notarize a block for the current view, and vote for it
    /// simultaneously.
    ShouldVoteAndMNotarize {
        /// Current view number (for which the replica should notarize and vote).
        view: u64,
        /// The hash of the block that the replica should notarize and vote for.
        block_hash: [u8; blake3::OUT_LEN],
        /// Whether the replica should forward the M-notarization to the network layer.
        should_forward_m_notarization: bool,
    },

    /// If the current replica should vote for a block for the current view, and progress to the
    /// next view simultaneously.
    ShouldVoteAndProgressToNextView {
        /// Current view number (for which the replica should vote and progress to the next view).
        old_view: u64,
        /// The hash of the block that the replica should vote and progress to the next view for.
        block_hash: [u8; blake3::OUT_LEN],
        /// New view number (for which the replica should progress to).
        new_view: u64,
        /// The leader's ID of the new view.
        leader: PeerId,
        /// Whether the replica should forward the M-notarization to the network layer.
        should_forward_m_notarization: bool,
    },

    /// If the current replica should progress to the next view.
    ProgressToNextView {
        /// New view number (for which the replica should progress to).
        new_view: u64,
        /// The leader's ID of the new view.
        leader: PeerId,
        /// The hash of the notarized block that the replica should progress to the next view for.
        notarized_block_hash: [u8; blake3::OUT_LEN],
        /// Whether the replica should forward the M-notarization to the network layer.
        should_forward_m_notarization: bool,
    },

    /// If the current replica should finalize the state for the the `view`.
    /// Notice that, `view` does not necessarily correspond to the current view,
    /// as the replica might have already progressed to a later view (in case,
    /// it has received a M-notarization for `view`, or a nullification).
    ShouldFinalize {
        /// Current view number (for which the replica should finalize).
        view: u64,
        /// The hash of the block that the replica should finalize.
        /// In case it is `None`, the replica should nullify the `view`,
        /// that is, the state machine replication protocol hasn't made
        /// any actual progress (due to a failure to collect enough votes
        /// to finalize a block for the `view`, and/or leader failure).
        block_hash: [u8; blake3::OUT_LEN],
    },

    /// If the current replica should vote for a block for the current view, and finalize it
    /// simultaneously.
    ShouldVoteAndFinalize {
        /// Current view number (for which the replica should vote and finalize).
        view: u64,
        /// The hash of the block that the replica should vote and finalize for.
        block_hash: [u8; blake3::OUT_LEN],
    },

    /// If the current replica should progress to a new view. This happens
    /// whenever the current replica receives either a M-notarization or a nullification
    /// for the current view.
    ProgressToNextViewOnNullification {
        /// New view number (for which the replica should change).
        new_view: u64,
        /// The leader's ID of the new view.
        leader: PeerId,
        /// The hash of the parent block that the replica should progress to the next view for.
        parent_block_hash: [u8; blake3::OUT_LEN],
        /// Whether the replica should broadcast a nullification for the new view.
        should_broadcast_nullification: bool,
    },

    /// If the current replica should broadcast a consensus message
    BroadcastConsensusMessage {
        /// The consensus message to be broadcasted by the current replica
        /// to its peers on the network.
        message: Box<ConsensusMessage<N, F, M_SIZE>>,
    },

    /// No operation is required at the moment, since (most likely) the replica
    /// already has made its state progress for the current view.
    NoOp,

    /// The replica still has not been able to make progress on the current view,
    /// and the view timeout has not been triggered yet, so the replica must await
    /// until it either receives a block to vote on the current view, or the timeout
    /// is triggered.
    Await,

    /// If the current replica should update the view context to a new view (in the future).
    ///
    /// This happens whenever the current replica receives a block for a future view,
    /// and the leader of the future view is not the current leader.
    ShouldUpdateView {
        /// New view number (for which the replica should change).
        new_view: u64,

        /// The leader's ID of the new view.
        leader: PeerId,
    },

    /// If the current replica should nullify the current view.
    ShouldNullifyView {
        /// View number (for which the replica should nullify).
        view: u64,
    },

    /// If the current replica should nullify a range of views starting from a past view.
    /// This creates a cascading nullification effect to clean up invalid view forks.
    /// The cascade nullifies from `start_view` up to and including `current_view`,
    /// then progresses to a new fresh view with the most recent valid parent.
    ShouldCascadeNullification {
        /// The starting view that triggered the cascade (the view that was just nullified)
        start_view: u64,
        /// Whether the replica should broadcast the nullification for the start_view
        should_broadcast_nullification: bool,
    },

    /// If the current replica should nullify a range of views because it detected
    /// conflicting evidence for a past view. This sends nullify messages for all
    /// views from `start_view` to `current_view` (inclusive) and progresses to a new view.
    ///
    /// This is different from `ShouldCascadeNullification` which is triggered by
    /// receiving a Nullification (aggregated proof). This event is triggered by
    /// local detection of conflicting evidence.
    ShouldNullifyRange {
        /// The starting view that triggered the nullification (where conflict was detected)
        start_view: u64,
    },

    /// If the current replica should request a missing block from peers.
    /// This happens when a view has received M-notarization (block_hash is known)
    /// but the actual block proposal was never received from the leader.
    ShouldRequestBlock {
        /// The view number for which the block is missing.
        view: u64,
        /// The expected block hash (from the M-notarization).
        block_hash: [u8; blake3::OUT_LEN],
    },

    /// If the current replica should request multiple missing blocks from peers.
    /// This is the batch version of `ShouldRequestBlock`, used when multiple views
    /// need block recovery simultaneously (e.g., after a node joins late).
    ShouldRequestBlocks {
        /// The list of (view, block_hash) pairs for which blocks are missing.
        requests: Vec<(u64, [u8; blake3::OUT_LEN])>,
    },
}
